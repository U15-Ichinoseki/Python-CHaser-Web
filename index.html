<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>CHaserWeb</title>
    <!-- Google FontsからIBM Plex Sans JPとIBM Plex Monoを読み込み -->
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans+JP:wght@400;600&family=IBM+Plex+Mono&display=swap" rel="stylesheet">
    <!-- CodeMirrorのCSSを読み込み -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.18/codemirror.min.css">
    <!-- CodeMirrorのテーマ -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.18/theme/monokai.min.css">
    <!-- Pyodideを読み込み -->
    <script src="https://cdn.jsdelivr.net/pyodide/v0.26.4/full/pyodide.js"></script>
    <style>
        /* 全体のスタイル */
        body {
            margin: 0;
            font-family: 'IBM Plex Sans JP', sans-serif;
            background-color: #1e1e1e;
            color: #ccc;
            scrollbar-width: thin;
            scrollbar-color: #555 #2d2d2d;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* ヘッダーのスタイル */
        .header {
            background-color: #333;
            padding: 10px 20px;
            display: flex;
            align-items: center;
            color: #fff;
        }

        .header h1 {
            margin: 0;
            font-size: 24px;
        }

        /* メインコンテナ */
        .container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* 左側の列（エディタとコンソール） */
        .left-column {
            flex: 1;
            display: flex;
            flex-direction: column;
            border-right: 1px solid #444;
            overflow: hidden;
        }

        /* エディタ部分 */
        #editor {
            flex-grow: 1;
            overflow: auto;
        }

        /* ボタン群 */
        .button-group {
            display: flex;
            padding: 10px;
            background-color: #2d2d2d;
            border-top: 1px solid #444;
        }

        .button-group button {
            background-color: #3c3c3c;
            color: #fff;
            border: none;
            padding: 8px 16px;
            margin-right: 10px;
            cursor: pointer;
            border-radius: 4px;
            font-family: 'IBM Plex Sans JP', sans-serif;
        }

        .button-group button:hover {
            background-color: #555;
        }

        /* コンソール出力 */
        #console-output {
            background-color: #1e1e1e;
            color: #fff;
            padding: 10px;
            height: 100px;
            overflow-y: auto;
            font-family: monospace;
            border-top: 1px solid #444;
            scrollbar-width: thin;
            scrollbar-color: #555 #2d2d2d;
        }

        /* 右側の列（ゲーム画面） */
        .right-column {
            flex: 0 0 40%;
            background-color: #252526;
            display: flex;
            flex-direction: column;
            padding: 10px;
            box-sizing: border-box;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: #555 #2d2d2d;
        }

        /* ゲーム情報 */
        #game-info {
            margin-bottom: 20px;
        }

        #game-info h2 {
            color: #fff;
            font-size: 18px;
            margin-bottom: 10px;
        }

        /* ゲームグリッド */
        #game-grid {
            display: grid;
            grid-template-columns: repeat(17, 30px);
            grid-template-rows: repeat(19, 30px);
            gap: 1px;
            overflow: auto;
            scrollbar-width: thin;
            scrollbar-color: #555 #2d2d2d;
        }

        /* セルのサイズを変更 */
        .cell {
            width: 29px;
            height: 29px;
            background-color: #333;
        }

        .floor {
            background-color: #E6E7E8;
        }

        .block {
            background-color: #777;
        }

        .item {
            background-color: #e91e63;
        }

        .player0 {
            background-color: #2196f3;
        }

        .player1 {
            background-color: #4caf50;
        }

        /* 隠しファイル入力 */
        #file-input {
            display: none;
        }

        /* CodeMirrorのスタイル調整 */
        .CodeMirror {
            height: 100%;
            background-color: #1e1e1e;
            color: #fff;
            font-size: 16px;
            font-family: 'IBM Plex Mono', monospace;
            scrollbar-width: thin;
            scrollbar-color: #555 #2d2d2d;
        }

        /* WebKitベースのブラウザ用スクロールバーのカスタマイズ */
        /* 全体のスクロールバー */
        body::-webkit-scrollbar {
            width: 12px;
        }

        body::-webkit-scrollbar-track {
            background: #2d2d2d;
        }

        body::-webkit-scrollbar-thumb {
            background-color: #555;
            border-radius: 6px;
            border: 3px solid #2d2d2d;
        }

        /* CodeMirrorのスクロールバー */
        .CodeMirror::-webkit-scrollbar {
            width: 12px;
        }

        .CodeMirror::-webkit-scrollbar-track {
            background: #2d2d2d;
        }

        .CodeMirror::-webkit-scrollbar-thumb {
            background-color: #555;
            border-radius: 6px;
            border: 3px solid #2d2d2d;
        }

        /* その他の要素のスクロールバー */
        .left-column::-webkit-scrollbar,
        .right-column::-webkit-scrollbar,
        #console-output::-webkit-scrollbar,
        #game-grid::-webkit-scrollbar {
            width: 12px;
        }

        .left-column::-webkit-scrollbar-track,
        .right-column::-webkit-scrollbar-track,
        #console-output::-webkit-scrollbar-track,
        #game-grid::-webkit-scrollbar-track {
            background: #2d2d2d;
        }

        .left-column::-webkit-scrollbar-thumb,
        .right-column::-webkit-scrollbar-thumb,
        #console-output::-webkit-scrollbar-thumb,
        #game-grid::-webkit-scrollbar-thumb {
            background-color: #555;
            border-radius: 6px;
            border: 3px solid #2d2d2d;
        }

        /* 全角スペースを可視化するスタイル */
        .cm-full-width-space {
            background-color: rgba(255, 0, 0, 0.3);
        }

        /* 不可視文字（スペース）を可視化するスタイル */
        .cm-whitespace-space::before {
            content: '·';
            color: rgba(128, 128, 128, 0.7);
            position: absolute;
        }

        /* インデントガイド用のスタイル */
        .CodeMirror-code .CodeMirror-line::before {
            content: '';
            position: absolute;
            border-left: 1px solid rgba(128, 128, 128, 0.3);
            height: 100%;
            pointer-events: none;
        }

        /* インデントレベルに応じて左位置を調整 */
        .CodeMirror-code .CodeMirror-line {
            position: relative;
        }

        /* インデントレベルのクラスを定義 */
        .CodeMirror-code .CodeMirror-line.indent-level-1::before { left: 4ch; }
        .CodeMirror-code .CodeMirror-line.indent-level-2::before { left: 8ch; }
        .CodeMirror-code .CodeMirror-line.indent-level-3::before { left: 12ch; }
        .CodeMirror-code .CodeMirror-line.indent-level-4::before { left: 16ch; }
        .CodeMirror-code .CodeMirror-line.indent-level-5::before { left: 20ch; }

        /* 凡例のスタイル */
        #legend {
            margin-top: 20px;
        }

        #legend h3 {
            color: #fff;
            font-size: 16px;
            margin-bottom: 10px;
        }

        #legend ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        #legend li {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }

        .legend-cell {
            width: 20px;
            height: 20px;
            margin-right: 10px;
        }

        .legend-cell.floor {
            background-color: #E6E7E8;
        }

        .legend-cell.block {
            background-color: #777;
        }

        .legend-cell.item {
            background-color: #e91e63;
        }

        .legend-cell.player0 {
            background-color: #2196f3;
        }

        .legend-cell.player1 {
            background-color: #4caf50;
        }

    </style>
</head>
<body>
    <div class="header">
        <h1>CHaserWeb</h1>
    </div>
    <div class="container">
        <!-- 左側の列（エディタとコンソール） -->
        <div class="left-column">
            <textarea id="editor"></textarea>
            <div class="button-group">
                <button id="run-button">実行</button>
                <button id="download-button">ダウンロード</button>
                <button id="upload-button">アップロード</button>
                <!-- ファイル入力要素（非表示） -->
                <input type="file" id="file-input" accept=".py">
            </div>
            <div id="console-output"></div>
        </div>
        <!-- 右側の列（ゲーム画面） -->
        <div class="right-column">
            <div id="game-info">
                <h2>ゲーム情報</h2>
                <p id="turn-number">Turn: 150</p>
                <p id="player-scores">Scores - あなた: 0, サンプルAI: 0</p>
                <div id="game-display">
                    <h2>ゲーム画面</h2>
                    <div id="game-grid"></div>
                    <!-- 凡例を追加 -->
                    <div id="legend">
                        <h3>マス種類</h3>
                        <ul>
                            <li><span class="legend-cell floor"></span> 床</li>
                            <li><span class="legend-cell block"></span> ブロック</li>
                            <li><span class="legend-cell item"></span> アイテム（ハート）</li>
                            <li><span class="legend-cell player0"></span> あなた</li>
                            <li><span class="legend-cell player1"></span> サンプルAI</li>
                        </ul>
                    </div>
                </div>
        </div>
    </div>

    <!-- CodeMirrorのJSを読み込み -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/codemirror.min.js"></script>
    <!-- CodeMirrorのPythonモードを読み込み -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/mode/python/python.min.js"></script>
    <!-- CodeMirrorのキー設定（任意） -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/keymap/sublime.min.js"></script>
    <!-- CodeMirrorのアドオン（任意） -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/addon/edit/matchbrackets.min.js"></script>

    <script>
        // CodeMirrorエディタの初期化
        var editor = CodeMirror.fromTextArea(document.getElementById('editor'), {
            mode: 'python',
            lineNumbers: true,
            indentUnit: 4,
            theme: 'monokai',
            autoCloseBrackets: true,
            matchBrackets: true,
            tabSize: 4,
            indentWithTabs: false,
            extraKeys: {
                Tab: function(cm) {
                    var spaces = Array(cm.getOption("indentUnit") + 1).join(" ");
                    cm.replaceSelection(spaces);
                }
            },
        });

        // タブ文字をスペースに置き換える
        function replaceTabsWithSpaces(str) {
            return str.replace(/\t/g, '    ');
        }

        // sample.pyをエディタに読み込む（ユーザー提供のコード）
        editor.setValue(replaceTabsWithSpaces(`# sample
import CHaser # 同じディレクトリに CHaser.py がある前提

"""
このファイルを直接実行したときに実行する関数．
実行するまでの経緯はファイルの下部に記載．

get_ready() → 行動関数 → get_ready() → ... の順で必ず処理を行う．
行動関数は「内容_方向()」の命名規則に従って名付けられる．

内容は「walk」「look」「search」「put」の4種類．
方向は「right」「up」「left」「down」の4種類．この組み合わせで関数を命名．
例) walk_up()，search_right() など

行動関数が返すリストは行動後のマップ情報9つ．
[ ][x][x]
[ ][C][♡]
[H][ ][ ]
このときは [0, 2, 2, 0, 0, 3, 1, 0, 0] が返る．
"""
def main():
    value = [] # フィールド情報を保存するリスト
    client = CHaser.Client() # サーバーと通信するためのインスタンス

    while(True):
        value = client.get_ready() # サーバーに行動準備が完了したと伝える
        # 最優先条件：上下左右に敵がいるか->いたら攻撃
        # 優先条件：  上下左右にハートがあるか->いたら移動
        # 最低条件：  壁を避ける。->壁がなければ上右下左の優先順で移動します。

        # 最優先条件
        if value[1] == 1:
            #上攻撃
            client.put_up()
        elif value[3] == 1:
            #左攻撃
            client.put_left()
        elif value[5] == 1:
            #右攻撃
            client.put_right()
        elif value[7] == 1:
            #下攻撃
            client.put_right()
        # 優先条件
        elif value[1] == 3:
            #上移動してハートとる
            client.walk_up()
        elif value[5] == 3:
            #右移動してハートとる
            client.walk_right()
        elif value[7] == 3:
            #下移動してハートとる
            client.walk_down()
        elif value[3] == 3:
            #左移動してハートとる
            client.walk_left()
        # 最低条件
        elif value[1] == 0:
            #上移動
            client.walk_up()
        elif value[5] == 0:
            #右移動
            client.walk_right()
        elif value[7] == 0:
            #下移動
            client.walk_down()
        elif value[3] == 0:
            #左移動
            client.walk_left()
"""
関数、繰り返し処理は使っていません。
pythonを学習した上で自分で修正してみてください。

python sample.py のようにこのファイルを直接実行すると，
__name__ は "__main__" となる．これを利用して main() を実行する．
"""
if __name__ == "__main__":
    main()
`));

        let pyodideReadyPromise = loadPyodide();

        // タイマーIDとゲーム実行フラグの定義
        let turnTimeout;
        let gameRunning = false;

        // chaserCodeとtransformerCodeをグローバルに定義
        let chaserCode = `
# -*- coding: utf-8 -*-
#
# このコードは、CHaser Server on Ruby (unofficial)のコードおよびアルゴリズムを参考にしています。
#
# オリジナルの著作権表示：
# Copyright (c) 2018 Tadakatsu Akisato
#
# オリジナルのライセンス：
# This software is released under the MIT License.
# http://opensource.org/licenses/mit-license.php
#
import re
import sys
import time
from js import updateGameDisplay  # JavaScriptの関数をインポート

# マップ用の定数を定義
M_FLOOR = 0  # 床
M_CHARA = 1  # キャラクター
M_BLOCK = 2  # ブロック
M_ITEM = 3   # アイテム（ハート）

class Game:
    """CHaserゲームのロジックを管理するクラス。"""

    def __init__(self):
        """ゲームの初期化を行う。"""
        # マップデータを埋め込みで定義
        self.map_data_str = (
            "N:basic\\n"
            "T:150\\n"
            "S:15,17\\n"
            "D:0,0,0,0,0,0,0,0,0,3,0,0,0,0,0\\n"
            "D:0,0,0,0,0,2,2,3,0,2,0,0,3,2,0\\n"
            "D:0,0,0,0,0,3,0,0,0,3,0,0,0,3,0\\n"
            "D:0,0,0,3,0,0,0,3,0,0,0,3,0,0,3\\n"
            "D:0,0,0,0,3,0,3,0,0,2,0,0,0,3,0\\n"
            "D:0,2,2,3,0,2,0,0,3,2,3,0,3,2,0\\n"
            "D:0,3,0,0,0,3,0,0,0,3,0,0,0,3,0\\n"
            "D:0,0,0,3,0,0,3,0,0,0,0,3,0,0,0\\n"
            "D:3,0,3,2,0,3,0,3,0,3,0,2,3,0,3\\n"
            "D:0,0,0,3,0,0,0,0,3,0,0,3,0,0,0\\n"
            "D:0,3,0,0,0,3,0,0,0,3,0,0,0,3,0\\n"
            "D:0,2,3,0,3,2,3,0,0,2,0,3,2,2,0\\n"
            "D:0,3,0,0,0,2,0,0,3,0,3,0,0,0,0\\n"
            "D:3,0,0,3,0,0,0,3,0,0,0,3,0,0,0\\n"
            "D:0,3,0,0,0,3,0,0,0,3,0,0,0,0,0\\n"
            "D:0,2,3,0,0,2,0,3,2,2,0,0,0,0,0\\n"
            "D:0,0,0,0,0,3,0,0,0,0,0,0,0,0,0\\n"
            "H:1,1\\n"
            "H:13,15\\n"
        )
        # ゲームの初期化
        self.initialize_game()

    def initialize_game(self):
        """ゲームに必要な変数を初期化する。"""
        self.game_map = []  # マップデータ
        self.names = ["あなた", "サンプルAI"]  # プレイヤー名
        self.chara_x = []  # 各プレイヤーのX座標
        self.chara_y = []  # 各プレイヤーのY座標
        self.score = [0, 0]  # スコア
        self.turn = -1  # 現在のターン数
        self.life = [1, 1]  # 各プレイヤーの生存フラグ（1:生存、0:死亡）
        self.put_winner = 0  # 'put'による勝者の判定用
        self.turn_max = 150  # 最大ターン数

        # マップデータの解析とゲームの準備
        self.parse_map_data()

    def parse_map_data(self):
        """マップデータを解析してゲームマップを構築する。"""
        lines = self.map_data_str.strip().split("\\n")
        map_line = 1  # マップデータは1から開始

        for line in lines:
            line = line.rstrip()
            line_body = re.sub(r"^.:", "", line)  # 行の先頭の"N:", "D:"などを除去

            if line:
                if line[0] == "N":
                    self.map_name = line_body  # マップ名
                elif line[0] == "T":
                    self.turn_max = int(line_body)  # 最大ターン数
                elif line[0] == "S":
                    map_size_s = line_body.split(",")
                    self.map_size_x = int(map_size_s[0]) + 2  # マップの横サイズ（両端に壁を追加）
                    self.map_size_y = int(map_size_s[1]) + 2  # マップの縦サイズ（上下に壁を追加）
                    self.game_map = [[] for _ in range(self.map_size_y)]  # マップデータの初期化
                elif line[0] == "D":
                    # マップの各行のデータ
                    line_body = "2," + line_body + ",2"  # 左右に壁（ブロック）を追加
                    map_row = [int(data) for data in line_body.split(",")]
                    self.game_map[map_line] = map_row
                    map_line += 1
                elif line[0] == "H":
                    # HOTプレイヤーの初期位置
                    chara_s = line_body.split(",")
                    self.chara_x.insert(1, int(chara_s[0]) + 1)
                    self.chara_y.insert(1, int(chara_s[1]) + 1)
                elif line[0] == "C":
                    # COOLプレイヤーの初期位置
                    chara_s = line_body.split(",")
                    self.chara_x.insert(0, int(chara_s[0]) + 1)
                    self.chara_y.insert(0, int(chara_s[1]) + 1)

        # マップの上下に壁（ブロック）の行を追加
        block_row = [M_BLOCK] * self.map_size_x
        self.game_map[0] = block_row
        self.game_map[self.map_size_y - 1] = block_row

    def get_map_value(self, x, y, c):
        """指定した座標のマップの値を取得する。"""
        if x < 0 or y < 0 or x >= self.map_size_x or y >= self.map_size_y:
            return M_BLOCK  # 範囲外はブロックとする
        if x == self.chara_x[1 - c] and y == self.chara_y[1 - c] and self.game_map[y][x] != M_BLOCK:
            return M_CHARA  # 敵キャラクターがいる場合
        return self.game_map[y][x]

    def get_nearby_information(self, player_id):
        """プレイヤーの周囲9マスの情報を取得する。"""
        values = [1]  # 生存フラグをセット
        for j in range(9):
            values.append(
                self.get_map_value(
                    self.chara_x[player_id] + (j % 3) - 1,
                    self.chara_y[player_id] + (j // 3) - 1,
                    player_id,
                )
            )
        return values

    def process_walk(self, player_id, direction):
        """移動の処理を行う。"""
        old_x = self.chara_x[player_id]
        old_y = self.chara_y[player_id]
        if direction == "u":
            self.chara_y[player_id] -= 1
        elif direction == "d":
            self.chara_y[player_id] += 1
        elif direction == "r":
            self.chara_x[player_id] += 1
        elif direction == "l":
            self.chara_x[player_id] -= 1

        # アイテム（ハート）を取得した場合の処理
        if (
            self.get_map_value(self.chara_x[player_id], self.chara_y[player_id], player_id)
            == M_ITEM
        ):
            self.score[player_id] += 1
            self.game_map[self.chara_y[player_id]][self.chara_x[player_id]] = M_FLOOR
            self.game_map[old_y][old_x] = M_BLOCK  # 移動元にブロックを置く
        else:
            self.game_map[old_y][old_x] = M_FLOOR  # 移動元を床にする

    def process_put(self, player_id, direction):
        """ブロック設置の処理を行う。"""
        if direction == "u":
            self.game_map[self.chara_y[player_id] - 1][self.chara_x[player_id]] = M_BLOCK
        elif direction == "d":
            self.game_map[self.chara_y[player_id] + 1][self.chara_x[player_id]] = M_BLOCK
        elif direction == "r":
            self.game_map[self.chara_y[player_id]][self.chara_x[player_id] + 1] = M_BLOCK
        elif direction == "l":
            self.game_map[self.chara_y[player_id]][self.chara_x[player_id] - 1] = M_BLOCK

    def process_look(self, player_id, direction):
        """Lookコマンドの処理を行う。指定した方向の2マス先を中心とした9マスの情報を取得する。"""
        if direction == "u":
            x = self.chara_x[player_id]
            y = self.chara_y[player_id] - 2
        elif direction == "d":
            x = self.chara_x[player_id]
            y = self.chara_y[player_id] + 2
        elif direction == "r":
            x = self.chara_x[player_id] + 2
            y = self.chara_y[player_id]
        elif direction == "l":
            x = self.chara_x[player_id] - 2
            y = self.chara_y[player_id]
        else:
            raise ValueError("無効な方向が指定されました: {}".format(direction))

        values = [1]  # 生存フラグ
        for j in range(9):
            values.append(
                self.get_map_value(
                    x + (j % 3) - 1,
                    y + (j // 3) - 1,
                    player_id,
                )
            )
        return values

    def process_search(self, player_id, direction):
        """Searchコマンドの処理を行う。指定した方向に9マス先までの情報を取得する。"""
        x = self.chara_x[player_id]
        y = self.chara_y[player_id]
        values = [1]  # 生存フラグ
        if direction == "u":
            for d in range(1, 10):
                values.append(self.get_map_value(x, y - d, player_id))
        elif direction == "d":
            for d in range(1, 10):
                values.append(self.get_map_value(x, y + d, player_id))
        elif direction == "r":
            for d in range(1, 10):
                values.append(self.get_map_value(x + d, y, player_id))
        elif direction == "l":
            for d in range(1, 10):
                values.append(self.get_map_value(x - d, y, player_id))
        else:
            raise ValueError("無効な方向が指定されました: {}".format(direction))
        return values

    def process_action(self, player_id, code):
        """プレイヤーの行動を処理し、結果を返す。"""
        result_values = [1]  # 初期値として生存フラグを設定

        # コマンドの形式をチェック
        if not re.match(r"^[wpls][udrl]$", code):
            raise ValueError("無効なコマンドが入力されました: {}".format(code))

        action = code[0]
        direction = code[1]

        if action == "w":
            # Walk（移動）
            self.process_walk(player_id, direction)
            result_values = self.get_nearby_information(player_id)
        elif action == "p":
            # Put（ブロック設置）
            self.process_put(player_id, direction)
            result_values = self.get_nearby_information(player_id)
        elif action == "s":
            # Search（サーチ）
            result_values = self.process_search(player_id, direction)
        elif action == "l":
            # Look（ルック）
            result_values = self.process_look(player_id, direction)
        else:
            result_values = self.get_nearby_information(player_id)

        # 生死判定
        self.check_player_status()

        result_values[0] = self.life[player_id]  # 生存フラグを更新
        return result_values

    def check_player_status(self):
        """プレイヤーの生死を判定する。"""
        for j in range(2):
            # プレイヤーがブロックに埋まっている場合は死亡
            if self.get_map_value(self.chara_x[j], self.chara_y[j], j) == M_BLOCK:
                self.life[j] = 0
                self.put_winner = 1 - j  # 相手の勝利
            # 四方がブロックで囲まれている場合は死亡
            if (
                self.get_map_value(self.chara_x[j], self.chara_y[j] - 1, j) == M_BLOCK
                and self.get_map_value(self.chara_x[j], self.chara_y[j] + 1, j) == M_BLOCK
                and self.get_map_value(self.chara_x[j] + 1, self.chara_y[j], j) == M_BLOCK
                and self.get_map_value(self.chara_x[j] - 1, self.chara_y[j], j) == M_BLOCK
            ):
                self.life[j] = 0
                self.put_winner = 1 - j  # 相手の勝利

    def opponent_action(self):
        """サンプルボット（相手プレイヤー）の行動を決定し、処理する。"""
        player_id = 1  # 相手プレイヤーは1
        value = self.get_nearby_information(player_id)[1:]  # 生存フラグを除外
        code = None

        # 行動を決定
        if value[1] == M_CHARA:
            code = "pu"  # 上攻撃
        elif value[3] == M_CHARA:
            code = "pl"  # 左攻撃
        elif value[5] == M_CHARA:
            code = "pr"  # 右攻撃
        elif value[7] == M_CHARA:
            code = "pd"  # 下攻撃
        elif value[1] == M_ITEM:
            code = "wu"  # 上移動
        elif value[5] == M_ITEM:
            code = "wr"  # 右移動
        elif value[7] == M_ITEM:
            code = "wd"  # 下移動
        elif value[3] == M_ITEM:
            code = "wl"  # 左移動
        elif value[1] == M_FLOOR:
            code = "wu"  # 上移動
        elif value[5] == M_FLOOR:
            code = "wr"  # 右移動
        elif value[7] == M_FLOOR:
            code = "wd"  # 下移動
        elif value[3] == M_FLOOR:
            code = "wl"  # 左移動
        else:
            code = "wr"  # デフォルト行動

        # 行動を処理
        self.process_action(player_id, code)

    def is_game_over(self):
        """ゲーム終了の判定を行う。"""
        return self.life[0] == 0 or self.life[1] == 0 or self.turn >= self.turn_max

    def judge_winner(self):
        """勝者の判定を行う。"""
        if self.life[0] == 0 and self.life[1] == 0:
            winner = self.put_winner  # 両者死亡なら'put'した方が勝ち
        elif self.life[0] == 0 and self.life[1] == 1:
            winner = 1  # 相手の勝ち
        elif self.life[0] == 1 and self.life[1] == 0:
            winner = 0  # あなたの勝ち
        elif self.score[0] == self.score[1]:
            winner = 2  # 引き分け
        elif self.score[0] > self.score[1]:
            winner = 0  # スコアであなたの勝ち
        else:
            winner = 1  # スコアで相手の勝ち
        return winner

    def get_game_state(self):
        """現在のゲーム状態を取得する（表示用）。"""
        # ゲームマップのコピーを作成
        map_d = [row[:] for row in self.game_map]

        # プレイヤーの位置を更新
        for i in range(2):
            map_d[self.chara_y[i]][self.chara_x[i]] = i + 4  # 4がplayer0、5がplayer1

        return map_d

    def disp(self):
        """ゲーム画面を更新する。"""
        game_state = self.get_game_state()
        # ターン数を減少させて表示
        remaining_turns = self.turn_max - self.turn
        # スコアをリストに変換
        scores = list(self.score)
        updateGameDisplay(game_state, remaining_turns, scores)  # JavaScriptの関数を呼び出し

class Client:
    """ユーザーのクライアントを表現するクラス。"""

    def __init__(self):
        """クライアントの初期化を行う。"""
        self.game = Game()  # ゲームのインスタンスを生成
        self.player_id = 0  # あなたはプレイヤー0（COOL）
        self.turn = 0  # 現在のターン
        self.game_over = False  # ゲーム終了フラグ

    def __order(self, order_str, gr_flag=False):
        """プレイヤーの行動を処理し、結果を取得する。"""
        if self.game_over:
            return None

        if self.game.life[self.player_id] == 0:
            print("ゲーム終了")
            self.game_over = True
            return None

        if gr_flag:
            if self.turn > 0:
                # 相手のターンを処理
                self.game.opponent_action()

            self.game.turn += 1
            self.turn += 1
            self.game.disp()  # ゲーム画面を更新
            values = self.game.get_nearby_information(self.player_id)
            return values[1:]  # [0]は生存フラグなので除外
        else:
            try:
                values = self.game.process_action(self.player_id, order_str)
            except Exception as e:
                print(f"エラーが発生しました: {e}")
                self.game_over = True
                return None

            self.game.disp()  # ゲーム画面を更新

            if self.game.is_game_over():
                print("\\nゲーム終了")
                winner = self.game.judge_winner()
                if winner == 0:
                    print("あなたの勝ちです！")
                elif winner == 1:
                    print("あなたの負けです。")
                else:
                    print("引き分けです。")
                self.game_over = True
                return values[1:]  # [0]は生存フラグなので除外

            return values[1:]  # [0]は生存フラグなので除外

    # サーバーとの通信で使用されるメソッド群
    def get_ready(self):
        return self.__order("gr", True)

    def walk_right(self):
        return self.__order("wr")

    def walk_up(self):
        return self.__order("wu")

    def walk_left(self):
        return self.__order("wl")

    def walk_down(self):
        return self.__order("wd")

    def put_right(self):
        return self.__order("pr")

    def put_up(self):
        return self.__order("pu")

    def put_left(self):
        return self.__order("pl")

    def put_down(self):
        return self.__order("pd")

    def look_up(self):
        return self.__order("lu")

    def look_down(self):
        return self.__order("ld")

    def look_right(self):
        return self.__order("lr")

    def look_left(self):
        return self.__order("ll")

    def search_up(self):
        return self.__order("su")

    def search_down(self):
        return self.__order("sd")

    def search_right(self):
        return self.__order("sr")

    def search_left(self):
        return self.__order("sl")
`;

        let transformerCode = `
import ast

def transform_code(source_code):
    # ソースコードをAST（抽象構文木）にパースします
    tree = ast.parse(source_code)

    class CodeTransformer(ast.NodeTransformer):
        def visit_FunctionDef(self, node):
            # 'main'関数のみを対象にします
            if node.name == 'main':
                new_body = []
                do_turn_func = None

                for stmt in node.body:
                    # while Trueループを探します
                    if isinstance(stmt, ast.While) and isinstance(stmt.test, ast.Constant) and stmt.test.value == True:
                        # 'do_turn'関数を作成します
                        do_turn_func = ast.FunctionDef(
                            name='do_turn',
                            args=ast.arguments(
                                posonlyargs=[],
                                args=[],
                                kwonlyargs=[],
                                kw_defaults=[],
                                defaults=[]
                            ),
                            body=stmt.body + [ast.Return(value=ast.Constant(value=True))],
                            decorator_list=[]
                        )
                    else:
                        new_body.append(stmt)

                # 'do_turn'関数を'main'に追加します
                if do_turn_func:
                    # 'do_turn'の最初にgame_overチェックを追加します
                    game_over_check = ast.If(
                        test=ast.Attribute(value=ast.Name(id='client', ctx=ast.Load()), attr='game_over', ctx=ast.Load()),
                        body=[ast.Return(value=ast.Constant(value=False))],
                        orelse=[]
                    )
                    do_turn_func.body.insert(0, game_over_check)

                    new_body.append(do_turn_func)
                    # 'main'を修正して'do_turn'を返すようにします
                    new_body.append(ast.Return(value=ast.Name(id='do_turn', ctx=ast.Load())))
                node.body = new_body
            return node

    # ASTを変換します
    transformer = CodeTransformer()
    new_tree = transformer.visit(tree)
    ast.fix_missing_locations(new_tree)

    # 変換されたコードを文字列に変換して返します
    transformed_code = ast.unparse(new_tree)
    return transformed_code
`;

        async function main() {
            let pyodide = await pyodideReadyPromise;

            // 必要なPythonパッケージをロード
            await pyodide.loadPackage(['micropip']);

            // print文をコンソール出力にリダイレクト
            let consoleOutput = document.getElementById('console-output');
            function writeToConsole(msg) {
                consoleOutput.textContent += msg + '\n';
                consoleOutput.scrollTop = consoleOutput.scrollHeight;
            }
            // writeToConsoleをグローバルスコープに配置
            window.writeToConsole = writeToConsole;

            // CDNの読み込み完了メッセージを表示
            writeToConsole('CDNの読み込みが完了しました');

            // 標準出力と標準エラー出力をリダイレクト
            pyodide.runPython(`
import sys
class ConsoleOutput:
    def __init__(self):
        self.buffer = ''
    def write(self, s):
        if s != '\\n':
            self.buffer += s
        else:
            from js import writeToConsole
            writeToConsole(self.buffer)
            self.buffer = ''
    def flush(self):
        pass
sys.stdout = sys.stderr = ConsoleOutput()

# カスタムの例外フックを定義
def custom_excepthook(exctype, value, tb):
    import traceback
    from js import writeToConsole
    tb_text = ''.join(traceback.format_exception(exctype, value, tb))
    writeToConsole(tb_text)

# カスタムの例外フックを設定
sys.excepthook = custom_excepthook
`);

            // updateGameDisplayをPythonから使用できるようにする
            function updateGameDisplay(game_state, turn, scores) {
                // scoresをJavaScriptの配列に変換
                if (scores.toJs) {
                    scores = scores.toJs();
                }

                // 既存のグリッドをクリア
                let gameGrid = document.getElementById('game-grid');
                gameGrid.innerHTML = '';

                // game_stateに基づいてセルを生成
                for (let row of game_state) {
                    for (let cell of row) {
                        let cellDiv = document.createElement('div');
                        cellDiv.classList.add('cell');
                        if (cell === 0) {
                            cellDiv.classList.add('floor');
                        } else if (cell === 2) {
                            cellDiv.classList.add('block');
                        } else if (cell === 3) {
                            cellDiv.classList.add('item');
                        } else if (cell === 4) {
                            cellDiv.classList.add('player0');
                        } else if (cell === 5) {
                            cellDiv.classList.add('player1');
                        } else {
                            cellDiv.classList.add('floor');
                        }
                        gameGrid.appendChild(cellDiv);
                    }
                }

                // ターン数とスコアを更新
                document.getElementById('turn-number').textContent = `Turn: ${turn}`;
                document.getElementById('player-scores').textContent = `Scores - あなた: ${scores[0]}, サンプルAI: ${scores[1]}`;
            }

            // 関数をグローバルスコープに配置
            window.updateGameDisplay = updateGameDisplay;

            // 実行ボタンがクリックされたときにユーザーコードを実行
            document.getElementById('run-button').addEventListener('click', async () => {
                consoleOutput.textContent = ''; // コンソール出力をクリア

                // 前回の実行を停止
                if (turnTimeout) {
                    clearTimeout(turnTimeout);
                    turnTimeout = null;
                }
                gameRunning = false;

                // Pyodideのグローバル変数をクリア
                pyodide.globals.clear();

                let userCode = editor.getValue();
                try {
                    // ユーザーコードを実行
                    await executeUserCode(userCode);
                } catch (err) {
                    writeToConsole(err.message || err);
                }
            });

            async function executeUserCode(userCode) {
                try {
                    // 必要なモジュールを再インポート
                    await pyodide.runPythonAsync(transformerCode);

                    // CHaser.pyを仮想ファイルシステムに書き込む
                    pyodide.FS.writeFile('CHaser.py', chaserCode);

                    // ユーザーコードを変換して実行
                    pyodide.globals.set('user_code', userCode);
                    await pyodide.runPythonAsync(`
transformed_code = transform_code(user_code)
                    `);
                    let transformed_code = pyodide.globals.get('transformed_code');
                    // 変換後のコードをコンソールに出力
                    console.log("Transformed Code:\\n", transformed_code);

                    pyodide.globals.set('transformed_code', transformed_code);
                    await pyodide.runPythonAsync(`
exec(transformed_code)
do_turn = main()
                    `);

                    // ゲーム実行フラグを設定
                    gameRunning = true;
                    runTurn();
                } catch (err) {
                    // エラーメッセージを表示
                    writeToConsole(err.message || err);
                }
            }

            function runTurn() {
                if (!gameRunning) return;

                let do_turn = pyodide.globals.get('do_turn');
                try {
                    let result = do_turn();
                    if (result) {
                        // ゲームが続行中の場合、次のターンを実行
                        turnTimeout = setTimeout(runTurn, 500);
                    } else {
                        // ゲーム終了
                        gameRunning = false;
                        console.log('ゲームが終了しました');
                    }
                } catch (err) {
                    // エラーメッセージを表示
                    writeToConsole(err.message || err);
                    gameRunning = false;
                    console.log('ゲームが終了しました');
                }
            }

            // ダウンロードボタンのクリックイベントを追加
            document.getElementById('download-button').addEventListener('click', () => {
                let code = editor.getValue();
                let filename = prompt('ファイル名を入力してください（拡張子は不要です）:', 'my_program');
                if (filename !== null) {
                    filename = filename.trim();
                    if (filename === '') {
                        alert('ファイル名が空です。');
                        return;
                    }
                    // ファイル名に拡張子を追加
                    let fullFilename = filename + '.py';
                    // ファイルを作成してダウンロード
                    let blob = new Blob([code], { type: 'text/plain' });
                    let url = URL.createObjectURL(blob);
                    let a = document.createElement('a');
                    a.href = url;
                    a.download = fullFilename;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }
            });

            // アップロードボタンのクリックイベントを追加
            document.getElementById('upload-button').addEventListener('click', () => {
                // ファイル選択ダイアログを表示
                document.getElementById('file-input').click();
            });

            // ファイルが選択されたときの処理
            document.getElementById('file-input').addEventListener('change', (event) => {
                let file = event.target.files[0];
                if (file) {
                    let reader = new FileReader();
                    reader.onload = function(e) {
                        let content = e.target.result;
                        editor.setValue(replaceTabsWithSpaces(content));
                    };
                    reader.readAsText(file);
                }
            });

            // 全角スペースを検出してハイライトするオーバーレイを定義
            var fullWidthSpaceOverlay = {
                token: function(stream) {
                    if (stream.peek() === '\u3000') {
                        stream.next();
                        return 'full-width-space';
                    }
                    while (!stream.eol() && stream.peek() !== '\u3000') {
                        stream.next();
                    }
                    return null;
                }
            };

            // エディタにオーバーレイを適用
            editor.addOverlay(fullWidthSpaceOverlay);

            // 不可視文字（スペース）を検出して可視化するオーバーレイを定義
            var invisiblesOverlay = {
                token: function(stream) {
                    if (stream.peek() === ' ') {
                        stream.next();
                        return 'whitespace-space';
                    } else {
                        stream.next();
                        return null;
                    }
                }
            };

            // エディタにオーバーレイを追加
            editor.addOverlay(invisiblesOverlay);

            // 各行のインデントレベルを計算してクラスを追加
            editor.on('renderLine', function(cm, line, element) {
                var text = line.text;
                var indentUnit = cm.getOption('indentUnit');
                var indentLevel = 0;
                var spaces = 0;

                for (var i = 0; i < text.length; i++) {
                    if (text[i] === ' ') {
                        spaces++;
                    } else {
                        break;
                    }
                }

                indentLevel = Math.floor(spaces / indentUnit);
                if (indentLevel > 0) {
                    element.classList.add('indent-level-' + indentLevel);
                }
            });

            editor.refresh(); // レンダリングを再実行

        }

        main();
    </script>
</body>
</html>
